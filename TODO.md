# Todo and planned features for the project

## To Do

- [ ] Support GDB unit test (Allowing to test C functions)
- [ ] Support Builtin unit test
- [ ] Eval filter
  - [ ] Input/Output filters
  - [ ] EvalInputFilter
  - [ ] Iter class
- [ ] Loops and Random values in tests
- [ ] Refactor output (cli interface)
- [ ] Migrate to pydantic
- [ ] Migrate from TinyKernel to RestrictedPython
- [ ] Short test summary info
- [ ] Implement standalone tests
- [ ] Migrate documentation to MkDocs

## New Features

### C unit tests

We may use the following to capture the prototype of a function:

```python
from elftools.elf.elffile import ELFFile

def extract_dwarf_info(filename):
    with open(filename, 'rb') as f:
        elffile = ELFFile(f)
        if not elffile.has_dwarf_info():
            print('No DWARF info found in', filename)
            return

        dwarf_info = elffile.get_dwarf_info()

        # Parcourir les unités de compilation pour trouver les fonctions
        for cu in dwarf_info.iter_CUs():
            print('Found a compilation unit:', cu.get_top_DIE().attributes)
            for die in cu.iter_DIEs():
                if die.tag == 'DW_TAG_subprogram':
                    name = die.attributes['DW_AT_name'].value.decode('utf-8')
                    print('Function:', name)

                    # Si l'élément DIE a des enfants (arguments de fonction)
                    for child in die.iter_children():
                        if child.tag == 'DW_TAG_formal_parameter':
                            param_name = child.attributes['DW_AT_name'].value.decode('utf-8')
                            param_type = child.attributes['DW_AT_type']
                            print(f'Param: {param_name}, Type: {param_type}')

extract_dwarf_info('foo.o')
```

```yaml
version: 1
tests:
  - name: Test function add
    function:
      name: add
      filename: foo.c
      types: [int, float, str] # Would be nice to identify it automatically
    build_cmd: gcc -flto {{filename}} runner.c # Default value
    args: [1, 2]
    stdout: 3
```

### Standalone Unit test

```python
# test_foo.py
# Add with: 'foo.py'

@baygon.stdin('2\n3\n')
@baygon.args('2', '3')
def test_blabla(stdout, stderr, exit_status, execution_time):
    assert stdout == '5\n'
    assert exit_status == 0

def test_bibi(executable: Executable):
    res = executable.run(args=['2', '3'], stdin='2\n3\n')
    assert res.stdout == '5\n'
    assert res.exit_status == 0
```

### Loops

Using different singleton iterators. They use internal states to generate value at each call. When an iterator is used, the test is repeated for each values generated by the iterator.

- `iter(min, max, step=1)`
- `rand(min, max, n=1, seed=42, unique=True)`

Variables and expressions:

- `{{a=42}}` Assign value to a variable, return the variable value
- `{{a * 2}}` Return the value of the expression

```yaml
version: 1
fixture:
  - 'fixture.py:myfixture'
tests:
  - name: Test loop
    args: [{{a=random(min=10, max=100, n=100)}}, 2]
    stdout:
      - contains: {{a}}
```

### Presentation

```text

---- 1.2.1 Test blabla --------------------------------- (green or red)
$ ./a.out 1 2
3

Assert stdout is 3 .............................. PASSED
Assert stderr is empty .......................... PASSED
Assert exit status is 0 ......................... PASSED

==== Short Test Summary Info ===========================

========================================================

29 failed, 63 passed, 4 skipped, 96 total tests
Baygon ran 96 tests in 0.01s on 2022-11-10 12:00:00
```
